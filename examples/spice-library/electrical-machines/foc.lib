

************************* FOC subcircuit ***************************************
.subckt foc iasm ibsm icsm rpm theta vbus qs_ref ds_ref
* transform the current to alpha-beta frame
Xiab iasm ibsm icsm iam ibm clark
** m= measured phase currents
Xiqs iam ibm theta iqsm idsm park
.param current_gain= 0.5
Eiq_meas iq_meas 0 value={v(iqsm)*current_gain}
Eid_meas id_meas 0 value={v(idsm)*current_gain}

**************** speed loop ***********************
* reference speed
.param rpm_ref=500
.param rpm_gain=1/500
vrpm rpm_ref 0 dc 0 PWL(0s 0V 1s {rpm_ref*rpm_gain})

* sampled rpm
Erpm_meas rpm_meas 0 value={v(rpm)*rpm_gain}
Xpi rpm_meas rpm_ref te_ref pi c=10u r=10k vdd=5


****************** current loop ***********************
* reference for pi controllers
EIqref iq_ref 0 value={1/(3/2*lambda_m)*v(te_ref) * current_gain}
EIdref id_ref 0 value={0 * current_gain}
Xpiq iqsm iq_ref vqs_ref pi c=10u r=10k vdd=5
Xpid idsm id_ref vds_ref pi c=10u r=10k vdd=5


* now generate the abc voltages
* multiply the output by Vbus
.param vdd=5
Eqs_ref qs_ref 0 value={v(vqs_ref)/vdd*v(vbus)}
Eds_ref ds_ref 0 value={v(vds_ref)/vdd*v(vbus)}

.ends foc


************************* SPVM average subcircuit ********************************
* average spvm block
.subckt spvm_avg q d theta a b c
Xpark q d theta alpha beta park
* use reverse park transformation to get the reference voltages
Xiclark alpha beta a b c iclark
.ends spvm_avg


***************************** PI controller subcircuit ********************************
* a subckt for the PI controller using a generic opamp
.subckt pi meas ref out c=1u r=10k vdd=5
r1 meas inn {r}
c1 inn out {c}
vdd vcc 0 {vdd}
vss vee 0 0
**xop in+ in- vcc vee out genopa1 POLE=20 GAIN=20k VOFF=10m ROUT=10
xop ref inn vcc vee out genopa1 pole=20 gain=20k voff=10m rout=10
.ends pi